#!/usr/bin/env python3
import heapq


# Generated by 2.3.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
def main():
    H, W = map(int, input().split())
    S = [input() for i in range(H)]
    pathed = [[-1]*W for i in range(H)]
    goal = [H-1, W-1]
    arround_next = [[-2, -1], [-2, 0], [-2, 1],
                    [-1, -2], [-1, 2],
                    [0, -2], [0, 2],
                    [1, -2], [1, 2],
                    [2, -1], [2, 0], [2, 1]]
    arround_check = [[-1, -1], [-1, 0], [-1, 1],
                     [0, -1], [0, 1],
                     [1, -1], [1, 0], [1, 1]]
    next_ = [[1, 0], [0, 1],
             [-1, 0], [0, -1]]

    q = []
    heapq.heapify(q)
    heapq.heappush(q, (0, 0, 0))
    pathed[0][0] = 0
    while q:
        block, x, y, = heapq.heappop(q)
        if pathed[x][y] < block:
            continue
        elif pathed[x][y] > block:
            pathed[x][y] = block
        if x == goal[0] and y == goal[1]:
            print(block)
            break
        # pathed[x][y] = block
        if S[x][y] == '#':
            for ch in arround_check:
                if (not(0 <= x+ch[0] < H and 0 <= y+ch[1] < W)) or (pathed[x+ch[0]][y+ch[1]] != -1 and pathed[x+ch[0]][y+ch[1]] <= block):
                    # if not(0 <= x+ch[0] < H and 0 <= y+ch[1] < W):
                    continue
                pathed[x+ch[0]][y+ch[1]] = block
                if x+ch[0] == goal[0] and y+ch[1] == goal[1]:

                    print(block)
                    exit()

            for ch in arround_next:
                if (not(0 <= x+ch[0] < H and 0 <= y+ch[1] < W)) or pathed[x+ch[0]][y+ch[1]] != -1:
                    # if not(0 <= x+ch[0] < H and 0 <= y+ch[1] < W):
                    continue
                if S[x+ch[0]][y+ch[1]] == '#':
                    pathed[x+ch[0]][y+ch[1]] = block+1
                    heapq.heappush(q, (block+1, x+ch[0], y+ch[1]))
                else:
                    pathed[x+ch[0]][y+ch[1]] = block
                    heapq.heappush(q, (block, x+ch[0], y+ch[1]))
        else:
            for ch in next_:
                if (not(0 <= x+ch[0] < H and 0 <= y+ch[1] < W)) or pathed[x+ch[0]][y+ch[1]] != -1:
                    continue
                if S[x+ch[0]][y+ch[1]] == '#':
                    pathed[x+ch[0]][y+ch[1]] = block+1
                    heapq.heappush(q, (block+1, x+ch[0], y+ch[1]))
                else:
                    pathed[x+ch[0]][y+ch[1]] = block
                    heapq.heappush(q, (block, x+ch[0], y+ch[1]))

                # Failed to predict input format


if __name__ == '__main__':

    main()
