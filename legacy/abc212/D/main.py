#!/usr/bin/env python3

# from collections import heapq
import heapq


class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
        self.count = 1


class BST:
    def __init__(self):  # コンストラクタ
        self.root = None  # ルート初期化
        # self.insert(num, incre)  # 挿入メソッドを使ってノードを挿入する

    def insert(self, data):
        n = self.root
        if n == None:
            self.root = Node(data)
            return
        else:
            while True:
                entry = n.data
                if data > entry:
                    if n.left is None:
                        n.left = Node(data)
                        return
                    n = n.left
                elif data < entry:
                    if n.right is None:
                        n.right = Node(data)
                        return
                    n = n.right
                else:
                    n.count += 1
                    return

    def search_min(self):
        root = self.root
        if root.right is None:
            if root.count == 1:
                self.root = self.root.left
            else:
                root.count -= 1
            return root.data

        while True:
            node = root.right
            if node.right is None:
                if node.count == 1:
                    root.right = node.left
                else:
                    root.count -= 1

                return node.data
            else:
                root, node = node, node.right

        # 二分木のノードを表すクラス

    class TreeNode:
        def __init__(self, x):
            self.val = x
            self.left = None
            self.right = None

    # 二分探索木rootからkeyの値を持つノードを削除する
    def deleteNode(self, node):

        # 子を持たない場合、自身をnullで置き換える
        if node.right is None:
            root = None
        # 1つの子を持つ場合、自身をその子で置き換える
        elif root.left is None or root.right is None:
            root = root.left or root.right
        else:
            # 2つの子を持つ場合、自身をそのsuccessorの値で上書きし、元のsuccessorを削除する
            root.val = self.successor(root)
            root.right = self.deleteNode(root.right, root.val)

        return root

    # nodeの右部分木からsuccessorの値を返す
    def successor(self, node):
        node = node.right
        while node.left:
            node = node.left
        return node.val
# Generated by 2.5.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)


def main():
    increase = 0
    li = []
    heapq.heapify(li)
    for i in range(int(input())):
        que = input()
        if que[0] == '1':
            heapq.heappush(li, int(que.split()[1]) - increase)

        elif que[0] == '2':
            increase += int(que.split()[1])

        else:
            print(heapq.heappop(li) + increase)
    pass


if __name__ == '__main__':
    main()
